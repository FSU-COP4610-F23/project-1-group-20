#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <fcntl.h>
#include "lexer.h"

void showPrompt();
void print(tokenlist *tokens);
char* replace_environment_variable(char *token);
char* replace_tilda(char *token);
char* get_path_to_command(char* command);
tokenlist* convert_tokens(tokenlist* tokens);
int setenv(const char *name, const char *value, int overwrite);

struct commandTable
{
	tokenlist* items[10];
	int size;
};

//////////////////////////////// MAIN //////////////////////////////
int main()
{
	int fileIndex = 0; 			// Keeps track of index of file
	char *input = "start";			// Holds user input typed into shell.
	tokenlist *tokens;			// User input is broken into tokens.
	int inputRedirect = 0; 			// Check if we use input redirection < 
	int outputRedirect = 0; 		// Check if we use output redirection >
	struct commandTable ct; ct.size=0;	// Command table holds tokens for each process.
	__pid_t pid;				// Process id.
	int status;				// Status of process.
	int fd[2];				// Holds 2 file descriptors for pipe in & pipe out.
	pipe(fd);				// Make pipe.
	char cwd[200];				// Current working directory of shell. Updated afer a "cd"
	bool internalCommand;

	// Loop till user types "exit"
	while (strcmp(input, "exit") != 0)
	{
		internalCommand = false;
		showPrompt();
		input = get_input(); 

		// User typed exit?
		if (strcmp(input, "exit") == 0)
		{
			// Print valid commands.
			exit(0);
		}

		// Tokensize and convert/expand.
		tokens = get_tokens(input);
		tokens = convert_tokens(tokens);

		// User typed cd?
		if (strcmp(tokens->items[0], "/bin/cd") == 0)
		{
			if (tokens->size == 1) {chdir(getenv("HOME"));}
			else {chdir(tokens->items[1]);}
			getcwd(cwd,200);
			setenv("PWD",cwd,1);
			internalCommand = true;
		}
		// User typed jobs?
		else if (strcmp(tokens->items[0], "/bin/jobs") == 0)
		{
			printf("%s\n","You typed JOBS!");
			internalCommand = true;
		}

		// Build command table.
		int i = 0;
		while (i<tokens->size)
		{
			bool done=false;
			tokenlist *processTokens = new_tokenlist();
			while (!done && i<tokens->size)
			{
				switch (tokens->items[i][0])
				{
					case '|' :
						done=true; tokens->items[i] = NULL; break;
					default :
						add_token(processTokens, tokens->items[i]);
				}
				i++;
			}
			// Add process tokens to next item in the command table.
			ct.items[ct.size] = processTokens;
			ct.size++;
		}

	if (!internalCommand)
	{	
		/*if (ct.size >= 1)
		{
			tokens = ct.items[0];
			inputRedirect = outputRedirect = 0;*/
			// Find out if input or output redirection is needed.
			/*for (int i=0; i<tokens->size; i++)
			{*/
				// Get first character of token...
			/*	switch (tokens->items[i][0])
				{
					case '>' :
						//output redirection
						fileIndex = i + 1;
						outputRedirect = 1 ;
						break;
					case '<' :
						//input redirection
						fileIndex = i + 1; 
						inputRedirect = 1; 
						break;
				}
			}*/
			// REDIRECTION.
			/*pid = fork();
 
			if (pid == 0) 
			{
				if (inputRedirect == 1)
				{
					tokens->items[fileIndex-1] = NULL;
					dup(STDIN_FILENO);
					close(STDIN_FILENO);
					fd[1] = open(tokens->items[fileIndex], O_RDONLY);
				}
				if (outputRedirect == 1)
				{
					tokens->items[fileIndex-1] = NULL;
					dup(STDOUT_FILENO);
					close(STDOUT_FILENO);
					fd[0] = open(tokens->items[fileIndex], O_RDWR | O_CREAT, 0600);
				}
				// Execute command.
				execv(tokens->items[0], tokens->items);
			}
			else {waitpid(pid, &status, 0);}*/

			////////////////////////////////TESTING/////////////////////////////////
			if (ct.size >= 1)
    {
        tokens = ct.items[0];
        int numRedirections = 0; // Count of redirection commands
        int inputRedirectIndices[ct.size]; // Array to store input redirection indices
        int outputRedirectIndices[ct.size]; // Array to store output redirection indices

        // Find out if input or output redirection is needed.
        for (int i = 0; i < tokens->size; i++)
        {
            // Check for input redirection
            if (tokens->items[i][0] == '<')
            {
                inputRedirectIndices[numRedirections] = i;
                numRedirections++;
            }
            // Check for output redirection
            else if (tokens->items[i][0] == '>')
            {
                outputRedirectIndices[numRedirections] = i;
                numRedirections++;
            }
        }

        // If there are redirection commands, process them in sequence
        if (numRedirections > 0)
        {
            for (int r = 0; r < numRedirections; r++)
            {
                pid = fork();

                if (pid == 0)
                {
                    // Handle input redirection
                    if (inputRedirectIndices[r] >= 0)
                    {
                        int fileIndex = inputRedirectIndices[r] + 1;
                        if (fileIndex < tokens->size)
                        {
                            tokens->items[inputRedirectIndices[r]] = NULL;
                            int input_fd = open(tokens->items[fileIndex], O_RDONLY);
                            if (input_fd != -1)
                            {
                                dup2(input_fd, STDIN_FILENO);
                                close(input_fd);
                            }
                            else
                            {
                                perror("open");
                                exit(EXIT_FAILURE);
                            }
                        }
                        else
                        {
                            fprintf(stderr, "Missing input file after '<'\n");
                            exit(EXIT_FAILURE);
                        }
                    }

                    // Handle output redirection
                    if (outputRedirectIndices[r] >= 0)
                    {
                        int fileIndex = outputRedirectIndices[r] + 1;
                        if (fileIndex < tokens->size)
                        {
                            tokens->items[outputRedirectIndices[r]] = NULL;
                            int output_fd = open(tokens->items[fileIndex], O_WRONLY | O_CREAT | O_TRUNC, 0666);
                            if (output_fd != -1)
                            {
                                dup2(output_fd, STDOUT_FILENO);
                                close(output_fd);
                            }
                            else
                            {
                                perror("open");
                                exit(EXIT_FAILURE);
                            }
                        }
                        else
                        {
                            fprintf(stderr, "Missing output file after '>'\n");
                            exit(EXIT_FAILURE);
                        }
                    }

                    // Execute the command
                    execv(tokens->items[0], tokens->items);
                    perror("execv");
                    exit(EXIT_FAILURE);
                }
                else
                {
                    waitpid(pid, &status, 0);
                }
            }
        }
        else
        {
            // No redirection commands found, execute the command directly
            pid = fork();

            if (pid == 0)
            {
                execv(tokens->items[0], tokens->items);
                perror("execv");
                exit(EXIT_FAILURE);
            }
            else
            {
                waitpid(pid, &status, 0);
            }
        }
    }
///////////////////////////////////EN

		//}
		else
		{
			// PIPE.
			// Loop thru command table.
			for (int i = 0; i < ct.size; i++)
			{
				pid = fork();
				
				if (pid == 0)
				{
					//child process
					if (i != 0)
					{
						dup2(fd[0], STDIN_FILENO);
						close(fd[0]);
						close(fd[1]);
					}

					if (i != ct.size - 1)
					{
						dup2(fd[1], STDOUT_FILENO);
						close(fd[0]);
						close(fd[1]);
					}

				execv(ct.items[i]->items[0], ct.items[i]->items);
				//child process exits
				}
				else
				{
					//parent process
					if (i != 0)
					{
						//close read
						close(fd[0]);
					}

					if (i != ct.size - 1)
					{
						//close write
						close(fd[1]);
					}

					//waiting for child process
					waitpid(pid, &status, 0);
				}
			}
		}
}

	// Reset and get next user input.
	free(input);
	free_tokens(tokens);
	ct.items[0] = NULL;
	ct.size = 0;
	}
// exit.
return 0;
}

//////////////////////////////////////// FUNCTIONS //////////////////////////////////////
void showPrompt()
{
	char *str1 = getenv("USER");
	char *str2 = getenv("MACHINE");
	char *str3 = getenv("PWD");
	printf("%s@", str1);
	printf("%s:", str2);
	printf("%s>", str3);
}

void print(tokenlist *tokens)
{
	printf("Tokenlist...\n");
	for (int i=0; i<tokens->size; i++) {printf("%s\n",tokens->items[i]);}
}

char* replace_environment_variable(char* token)
{
	char str[strlen(token)-1];
	for (int i=0; i<strlen(token); i++) 
	{
		str[i] = token[i+1];
	}
	char *b = (char*)malloc(strlen(getenv(str))+1);
	strcpy(b, getenv(str));
	free(token);
	return b;
}

char* replace_tilda(char* token)
{
	char str[strlen(token)-1];
	for (int i=0; i<strlen(token); i++) 
	{
		str[i] = token[i+1];
	}
	char *b = (char*)malloc(strlen(getenv("HOME"))+strlen(token));
	strcpy(b,getenv("HOME"));
	strcat(b,str);
	free(token);
	return b;
}

// First we get the paths from $PATH environment variable, tokenize this
// path list and append the command name to end of each path string. Then we 
// test each path with the access() function to see if that path is accessible.
// If so, this function will return the full path to where the command is located.
// If no path found, function returns NULL.
char* get_path_to_command(char* command)
{	
	char *p;
	char *paths;
	paths = (char*)malloc(strlen(getenv("PATH")+1));
	strcpy(paths,getenv("PATH"));
	char *delimitedPATH = strtok(paths,":");
	while (delimitedPATH != NULL)
	{	
		p = (char*)malloc(100);

		// Append the command we are searching for to end of path.
		strcpy(p,delimitedPATH);
		strcat(p,"/");
		strcat(p,command);

		// If path is accessible, return it.
		if (access(p, F_OK) == 0) {return p;}

		// Otherwise, move to next path.
		delimitedPATH = strtok(NULL,":");
		p = NULL;
	}
	// If we've gotten here, command was not found at any path. Return NULL.
	return p;
}

// Performs initial token conversions.
// Expands ~
// Converts $USER, $MACHINE, $PATH etc.
// Converts command names. For example, "ls" becomes "/bin/ls"
tokenlist* convert_tokens(tokenlist* tokens)
{
	// Loop thru tokens...
	for (int i=0; i<tokens->size; i++)
	{
		// First token should be a command like "ls" "echo" etc.
		if (i == 0)
		{
			// Do path search to locate it on the OS.
			tokens->items[0] = get_path_to_command(tokens->items[i]);

			if(tokens->items[0]==NULL)
			{
				printf("command not found.\n");
				exit(0);
			}
		}
		// Get first character of token...
		switch (tokens->items[i][0])
		{
			case '$' :
				// Replace environment variable.
				tokens->items[i] = replace_environment_variable(tokens->items[i]);
				break;
			case '~' :
				// Replace tilda with home folder.
				tokens->items[i] = replace_tilda(tokens->items[i]);
				break;
			case '|' :
				// If we reach a "pipe" then the next token should be a command token.
				tokens->items[i+1] = get_path_to_command(tokens->items[i+1]);
				break;
		}
	}
	return tokens;
}

